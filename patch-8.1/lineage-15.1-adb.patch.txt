diff -u -r system/core/adb/Android.mk.orig system/core/adb/Android.mk
--- system/core/adb/Android.mk.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/Android.mk	2019-12-02 17:55:26.180249000 +0900
@@ -113,6 +113,10 @@
 LOCAL_CFLAGS := $(LIBADB_CFLAGS) -DADB_HOST=0
 LOCAL_SRC_FILES := daemon/usb.cpp
 
+ifeq ($(TARGET_USES_LEGACY_ADB_INTERFACE),true)
+LOCAL_CFLAGS += -DLEGACY_ADB_INTERFACE
+endif
+
 LOCAL_SANITIZE := $(adb_target_sanitize)
 
 # Even though we're building a static library (and thus there's no link step for
@@ -357,6 +361,10 @@
 LOCAL_CFLAGS += -DALLOW_ADBD_ROOT=1
 endif
 
+ifeq ($(TARGET_USES_LEGACY_ADB_INTERFACE),true)
+LOCAL_CFLAGS += -DLEGACY_ADB_INTERFACE
+endif
+
 LOCAL_MODULE := adbd
 
 LOCAL_FORCE_STATIC_EXECUTABLE := true
diff -u -r system/core/adb/adb.h.orig system/core/adb/adb.h
--- system/core/adb/adb.h.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/adb.h	2019-12-02 17:55:26.180249000 +0900
@@ -120,7 +120,6 @@
     kCsNoPerm,  // Insufficient permissions to communicate with the device.
     kCsSideload,
     kCsUnauthorized,
-    kCsOnline,
 };
 
 
@@ -215,6 +214,9 @@
 #define CHUNK_SIZE (64*1024)
 
 #if !ADB_HOST
+#ifdef LEGACY_ADB_INTERFACE
+#define USB_ADB_PATH     "/dev/android_adb"
+#endif
 #define USB_FFS_ADB_PATH  "/dev/usb-ffs/adb/"
 #define USB_FFS_ADB_EP(x) USB_FFS_ADB_PATH#x
 
diff -u -r system/core/adb/commandline.cpp.orig system/core/adb/commandline.cpp
--- system/core/adb/commandline.cpp.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/commandline.cpp	2019-12-02 17:55:26.188249000 +0900
@@ -183,7 +183,7 @@
         "scripting:\n"
         " wait-for[-TRANSPORT]-STATE\n"
         "     wait for device to be in the given state\n"
-        "     State: device, recovery, sideload, online or bootloader\n"
+        "     State: device, recovery, sideload, or bootloader\n"
         "     Transport: usb, local, or any [default=any]\n"
         " get-state                print offline | bootloader | device\n"
         " get-serialno             print <serial-number>\n"
@@ -1036,10 +1036,10 @@
     }
 
     if (components[3] != "any" && components[3] != "bootloader" && components[3] != "device" &&
-        components[3] != "recovery" && components[3] != "sideload" && components[3] != "online") {
+        components[3] != "recovery" && components[3] != "sideload") {
         fprintf(stderr,
                 "adb: unknown state %s; "
-                "expected 'any', 'bootloader', 'device', 'recovery', 'online', or 'sideload'\n",
+                "expected 'any', 'bootloader', 'device', 'recovery', or 'sideload'\n",
                 components[3].c_str());
         return false;
     }
diff -u -r system/core/adb/daemon/main.cpp.orig system/core/adb/daemon/main.cpp
--- system/core/adb/daemon/main.cpp.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/daemon/main.cpp	2019-12-02 17:55:26.188249000 +0900
@@ -77,7 +77,7 @@
     bool drop = ro_secure;
 
     // ... except "adb root" lets you keep privileges in a debuggable build.
-    std::string prop = android::base::GetProperty("lineage.service.adb.root", "");
+    std::string prop = android::base::GetProperty("service.adb.root", "");
     bool adb_root = (prop == "1");
     bool adb_unroot = (prop == "0");
     if (ro_debuggable && adb_root) {
@@ -177,7 +177,11 @@
     drop_privileges(server_port);
 
     bool is_usb = false;
+#ifdef LEGACY_ADB_INTERFACE
+    if (access(USB_ADB_PATH, F_OK) == 0) {
+#else
     if (access(USB_FFS_ADB_EP0, F_OK) == 0) {
+#endif
         // Listen on USB.
         usb_init();
         is_usb = true;
diff -u -r system/core/adb/daemon/usb.cpp.orig system/core/adb/daemon/usb.cpp
--- system/core/adb/daemon/usb.cpp.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/daemon/usb.cpp	2019-12-02 17:55:26.188249000 +0900
@@ -64,7 +64,9 @@
 
 #define FUNCTIONFS_ENDPOINT_ALLOC       _IOR('g', 231, __u32)
 
+#ifndef LEGACY_ADB_INTERFACE
 static constexpr size_t ENDPOINT_ALLOC_RETRIES = 10;
+#endif
 
 static int dummy_fd = -1;
 
@@ -105,6 +107,138 @@
     struct usb_ext_compat_desc os_desc;
 } __attribute__((packed));
 
+#ifdef LEGACY_ADB_INTERFACE
+static void usb_adb_open_thread(void* x) {
+    struct usb_handle *usb = (struct usb_handle *)x;
+    int fd;
+
+    adb_thread_setname("usb open");
+
+    while (true) {
+        // wait until the USB device needs opening
+        std::unique_lock<std::mutex> lock(usb->lock);
+        while (!usb->open_new_connection) {
+            usb->notify.wait(lock);
+        }
+        usb->open_new_connection = false;
+        lock.unlock();
+
+        D("[ usb_thread - opening device ]");
+        do {
+            /* XXX use inotify? */
+            fd = unix_open("/dev/android_adb", O_RDWR);
+            if (fd < 0) {
+                // to support older kernels
+                fd = unix_open("/dev/android", O_RDWR);
+            }
+            if (fd < 0) {
+                std::this_thread::sleep_for(1s);
+            }
+        } while (fd < 0);
+        D("[ opening device succeeded ]");
+
+        close_on_exec(fd);
+        usb->fd = fd;
+
+        D("[ usb_thread - registering device ]");
+        register_usb_transport(usb, 0, 0, 1);
+    }
+
+    // never gets here
+    abort();
+}
+
+static int usb_adb_write(usb_handle *h, const void *data, int len)
+{
+    int n;
+
+    D("about to write (fd=%d, len=%d)", h->fd, len);
+    n = unix_write(h->fd, data, len);
+    if(n != len) {
+        D("ERROR: fd = %d, n = %d, errno = %d (%s)",
+            h->fd, n, errno, strerror(errno));
+        return -1;
+    }
+    if (h->kicked) {
+        D("usb_adb_write finished due to kicked");
+        return -1;
+    }
+    D("[ done fd=%d ]", h->fd);
+    return 0;
+}
+
+static int usb_adb_read(usb_handle *h, void *data, int len)
+{
+    D("about to read (fd=%d, len=%d)", h->fd, len);
+    while (len > 0) {
+        // The kernel implementation of adb_read in f_adb.c doesn't support
+        // reads larger then 4096 bytes. Read the data in 4096 byte chunks to
+        // avoid the issue. (The ffs implementation doesn't have this limit.)
+        int bytes_to_read = len < 4096 ? len : 4096;
+        int n = unix_read(h->fd, data, bytes_to_read);
+        if (n != bytes_to_read) {
+            D("ERROR: fd = %d, n = %d, errno = %d (%s)",
+                h->fd, n, errno, strerror(errno));
+            return -1;
+        }
+        if (h->kicked) {
+            D("usb_adb_read finished due to kicked");
+            return -1;
+        }
+        len -= n;
+        data = ((char*)data) + n;
+    }
+    D("[ done fd=%d ]", h->fd);
+    return 0;
+}
+
+static void usb_adb_kick(usb_handle *h) {
+    D("usb_kick");
+    // Other threads may be calling usb_adb_read/usb_adb_write at the same time.
+    // If we close h->fd, the file descriptor will be reused to open other files,
+    // and the read/write thread may operate on the wrong file. So instead
+    // we set the kicked flag and reopen h->fd to a dummy file here. After read/write
+    // threads finish, we close h->fd in usb_adb_close().
+    h->kicked = true;
+    TEMP_FAILURE_RETRY(dup2(dummy_fd, h->fd));
+}
+
+static void usb_adb_close(usb_handle *h) {
+    h->kicked = false;
+    adb_close(h->fd);
+    // Notify usb_adb_open_thread to open a new connection.
+    h->lock.lock();
+    h->open_new_connection = true;
+    h->lock.unlock();
+    h->notify.notify_one();
+}
+
+static void usb_adb_init()
+{
+    usb_handle* h = new usb_handle();
+
+    h->write = usb_adb_write;
+    h->read = usb_adb_read;
+    h->kick = usb_adb_kick;
+    h->close = usb_adb_close;
+
+    // Open the file /dev/android_adb_enable to trigger
+    // the enabling of the adb USB function in the kernel.
+    // We never touch this file again - just leave it open
+    // indefinitely so the kernel will know when we are running
+    // and when we are not.
+    int fd = unix_open("/dev/android_adb_enable", O_RDWR);
+    if (fd < 0) {
+       D("failed to open /dev/android_adb_enable");
+    } else {
+        close_on_exec(fd);
+    }
+
+    D("[ usb_init - starting thread ]");
+    std::thread(usb_adb_open_thread, h).detach();
+}
+#else
+
 static struct func_desc fs_descriptors = {
     .intf = {
         .bLength = sizeof(fs_descriptors.intf),
@@ -458,11 +592,16 @@
     D("[ usb_init - starting thread ]");
     std::thread(usb_ffs_open_thread, h).detach();
 }
+#endif
 
 void usb_init() {
     dummy_fd = adb_open("/dev/null", O_WRONLY);
     CHECK_NE(dummy_fd, -1);
+#ifdef LEGACY_ADB_INTERFACE
+    usb_adb_init();
+#else
     usb_ffs_init();
+#endif
 }
 
 int usb_write(usb_handle* h, const void* data, int len) {
diff -u -r system/core/adb/daemon/usb.h.orig system/core/adb/daemon/usb.h
--- system/core/adb/daemon/usb.h.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/daemon/usb.h	2019-12-02 17:55:26.188249000 +0900
@@ -34,6 +34,11 @@
     void (*kick)(usb_handle* h);
     void (*close)(usb_handle* h);
 
+#ifdef LEGACY_ADB_INTERFACE
+    // Legacy f_adb
+    int fd = -1;
+#endif
+
     // FunctionFS
     int control = -1;
     int bulk_out = -1; /* "out" from the host's perspective => source for adbd */
diff -u -r system/core/adb/services.cpp.orig system/core/adb/services.cpp
--- system/core/adb/services.cpp.orig	2019-02-15 10:27:53.000000000 +0900
+++ system/core/adb/services.cpp	2019-12-02 17:55:26.192249000 +0900
@@ -84,18 +84,7 @@
             return;
         }
 
-        std::string root_access = android::base::GetProperty("persist.sys.root_access", "0");
-        std::string build_type = android::base::GetProperty("ro.build.type", "");
-        std::string lineage_version = android::base::GetProperty("ro.lineage.version", "");
-
-        if (!lineage_version.empty() && build_type != "eng" && (std::stoi(root_access) & 2) != 2) {
-            WriteFdExactly(fd, "root access is disabled by system setting - "
-                    "enable in Settings -> System -> Development options\n");
-            adb_close(fd);
-            return;
-        }
-
-        android::base::SetProperty("lineage.service.adb.root", "1");
+        android::base::SetProperty("service.adb.root", "1");
         WriteFdExactly(fd, "restarting adbd as root\n");
         adb_close(fd);
     }
@@ -106,7 +95,7 @@
         WriteFdExactly(fd, "adbd not running as root\n");
         adb_close(fd);
     } else {
-        android::base::SetProperty("lineage.service.adb.root", "0");
+        android::base::SetProperty("service.adb.root", "0");
         WriteFdExactly(fd, "restarting adbd as non root\n");
         adb_close(fd);
     }
@@ -372,9 +361,7 @@
         const char* serial = sinfo->serial.length() ? sinfo->serial.c_str() : NULL;
         atransport* t = acquire_one_transport(sinfo->transport_type, serial, sinfo->transport_id,
                                               &is_ambiguous, &error);
-        if (t != nullptr && (sinfo->state == kCsAny || sinfo->state == t->GetConnectionState() ||
-                    (sinfo->state == kCsOnline && (t->GetConnectionState() == kCsRecovery ||
-                                                   t->GetConnectionState() == kCsDevice)) )) {
+        if (t != nullptr && (sinfo->state == kCsAny || sinfo->state == t->GetConnectionState())) {
             SendOkay(fd);
             break;
         } else if (!is_ambiguous) {
@@ -502,8 +489,6 @@
             sinfo->state = kCsBootloader;
         } else if (!strcmp(name, "-any")) {
             sinfo->state = kCsAny;
-        } else if (!strcmp(name, "-online")) {
-            sinfo->state = kCsOnline;
         } else {
             return nullptr;
         }
diff -u -r system/core/rootdir/ueventd.rc.orig system/core/rootdir/ueventd.rc
--- system/core/rootdir/ueventd.rc.orig	2019-02-15 10:27:57.000000000 +0900
+++ system/core/rootdir/ueventd.rc	2019-12-02 17:55:26.392249000 +0900
@@ -68,6 +68,8 @@
 # these should not be world writable
 /dev/diag                 0660   radio      radio
 /dev/diag_arm9            0660   radio      radio
+/dev/android_adb          0660   adb        adb
+/dev/android_adb_enable   0660   adb        adb
 /dev/ttyMSM0              0600   bluetooth  bluetooth
 /dev/uhid                 0660   uhid       uhid
 /dev/uinput               0660   system     bluetooth
